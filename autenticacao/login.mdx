---
title: /api/login
description: Autentica um usuário existente e retorna um token de acesso.
openapi: 'POST /api/login'
---

Este endpoint autentica usuários existentes na plataforma usando email e senha. Retorna um token JWT válido para acessar recursos protegidos.

<RequestExample>
<CodeGroup>

```bash cURL
curl -X POST "https://api.formsign.com.br/api/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "joao.silva@empresa.com.br",
    "password": "MinhaSenh@Segura123"
  }'
```

```javascript JavaScript
const response = await fetch('https://api.formsign.com.br/api/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    email: 'joao.silva@empresa.com.br',
    password: 'MinhaSenh@Segura123'
  })
});

const result = await response.json();
if (response.ok) {
  console.log('Login realizado com sucesso!');
  console.log('Token:', result.token);
  console.log('User ID:', result.user.userId);
  
  // Armazenar token para próximas requisições
  localStorage.setItem('authToken', result.token);
} else {
  console.error('Erro no login:', result.error);
}
```

```python Python
import requests
import json

payload = {
    "email": "joao.silva@empresa.com.br",
    "password": "MinhaSenh@Segura123"
}

response = requests.post(
    'https://api.formsign.com.br/api/login',
    json=payload
)

if response.status_code == 200:
    result = response.json()
    print(f"Login realizado com sucesso!")
    print(f"Token: {result['token']}")
    print(f"User ID: {result['user']['userId']}")
    
    # Salvar token para próximas requisições
    auth_token = result['token']
else:
    error = response.json()
    print(f"Erro no login: {error.get('error', 'Erro desconhecido')}")
```

```go Go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
)

func main() {
    payload := map[string]string{
        "email":    "joao.silva@empresa.com.br",
        "password": "MinhaSenh@Segura123",
    }
    
    jsonData, _ := json.Marshal(payload)
    resp, err := http.Post(
        "https://api.formsign.com.br/api/login",
        "application/json",
        bytes.NewBuffer(jsonData),
    )
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    
    if resp.StatusCode == 200 {
        var result map[string]interface{}
        json.Unmarshal(body, &result)
        
        fmt.Println("Login realizado com sucesso!")
        fmt.Printf("Token: %v\n", result["token"])
        fmt.Printf("User ID: %v\n", result["user"].(map[string]interface{})["userId"])
    } else {
        fmt.Printf("Erro no login: %s\n", string(body))
    }
}
```

```java Java
import java.net.http.*;
import java.net.URI;
import com.google.gson.Gson;
import java.util.Map;
import java.util.HashMap;

public class LoginUser {
    public static void main(String[] args) throws Exception {
        Map<String, String> payload = new HashMap<>();
        payload.put("email", "joao.silva@empresa.com.br");
        payload.put("password", "MinhaSenh@Segura123");
        
        String json = new Gson().toJson(payload);
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.formsign.com.br/api/login"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(json))
            .build();
            
        HttpResponse<String> response = HttpClient.newHttpClient()
            .send(request, HttpResponse.BodyHandlers.ofString());
            
        if (response.statusCode() == 200) {
            System.out.println("Login realizado com sucesso!");
            System.out.println("Response: " + response.body());
        } else {
            System.out.println("Erro no login: " + response.body());
        }
    }
}
```

</CodeGroup>
</RequestExample>

### Parâmetros (Body)

<ParamField body="email" type="string" required>
Email do usuário registrado na plataforma.
</ParamField>

<ParamField body="password" type="string" required>
Senha do usuário.
</ParamField>

### Respostas

<ResponseExample>

```json 200 Sucesso
{
  "message": "Login realizado com sucesso",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJ1c3JfYWJjMTIzNDU2Nzg5IiwiZW1haWwiOiJqb2FvLnNpbHZhQGVtcHJlc2EuY29tLmJyIiwiaWF0IjoxNzI1NTg5ODAwLCJleHAiOjE3MjU2NzYyMDB9...",
  "user": {
    "userId": "usr_abc123456789",
    "email": "joao.silva@empresa.com.br",
    "name": "João Silva"
  }
}
```

```json 400 Dados Inválidos
{
  "error": "Email e senha são obrigatórios"
}
```

```json 401 Credenciais Inválidas
{
  "error": "Email ou senha inválidos"
}
```

```json 401 Usuário Não Encontrado
{
  "error": "Usuário não encontrado"
}
```

```json 500 Erro Interno
{
  "error": "Erro interno do servidor"
}
```

</ResponseExample>

### Campos da Resposta

<ResponseField name="message" type="string">
Mensagem de confirmação do login.
</ResponseField>

<ResponseField name="token" type="string">
Token JWT válido por 24 horas para autenticação.
</ResponseField>

<ResponseField name="user" type="object">
Dados do usuário autenticado.
</ResponseField>

<ResponseField name="user.userId" type="string">
ID único do usuário no sistema.
</ResponseField>

<ResponseField name="user.email" type="string">
Email do usuário.
</ResponseField>

<ResponseField name="user.name" type="string">
Nome do usuário.
</ResponseField>

### Validações

- **Campos obrigatórios**: Email e senha devem ser fornecidos
- **Usuário existente**: O email deve estar cadastrado no sistema
- **Senha correta**: A senha deve corresponder à cadastrada
- **Conta ativa**: A conta deve estar ativa e não bloqueada

<Note>
**Validade do Token**: O token JWT retornado é válido por 24 horas. Após expirar, será necessário fazer login novamente.
</Note>

<Tip>
**Gerenciamento de Token**: Armazene o token de forma segura (localStorage no frontend, variável de ambiente no backend) e inclua-o no header `Authorization: Bearer <token>` para todas as requisições autenticadas.
</Tip>

<Warning>
**Segurança**: Nunca armazene senhas em texto plano. Este endpoint utiliza hash seguro para verificação de senhas.
</Warning>